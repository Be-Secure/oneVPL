<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>oneVPL++: oneVPL C++ API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="assets/customdoxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="assets/custom.js"></script>
</head>
<body>
<div class="mobile-nav"><i id="nav-btn"></i><a href="index.html">oneVPL++</a></div>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
   <div id="projectname">
     <a href="index.html">
      <div id="full-name">oneVPL++</div>
    </a>
   </div>
   <div id="projectbrief">C++ API Prototype for oneVPL</div>
  <div>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">oneVPL C++ API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The oneAPI C++ Video Processing Library is a programming interface for video decoding, encoding, and processing to build portable media pipelines on CPUs, GPUs, and other accelerators. It provides device discovery and selection in media centric and video analytics workloads and API primitives for zero-copy buffer sharing. oneVPL is backwards and cross-architecture compatible to ensure optimal execution on current and next generation hardware without source code changes.</p>
<p>oneVPL functions fall into the following categories</p>
<ul>
<li>DECODE Functions that decode compressed video streams into raw video frames</li>
<li>ENCODE Functions that encode raw video frames into compressed bitstreams</li>
<li>VPP Functions that perform video processing on raw video frames</li>
</ul>
<p>oneVPL functions are named after their functioning domain and category</p>
<p>This chapter describes the concepts used in programming with oneVPL.</p>
<p>The application must use the include file <a class="el" href="vpl_8hpp_source.html">vpl.hpp</a> for C++ programming.</p>
<p>Include these files:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;vpl.hpp&quot;</span>    <span class="comment">/* oneVPL include file */</span></div></div><!-- fragment --><p>Alternatively the vpl headers can be referenced directly as seen in the hello decode sample</p>
<p>Before calling any oneVPL functions, the application must initialize the library and create a oneVPL session. A oneVPL session maintains context for the use of any vpl functions</p>
<p><a class="anchor" id="invalid"></a></p><h5>The simplest initialization for a decode session</h5>
<p>The simplest initialization for a decode session is one that specifies the target device and target codec. In the snippet below, the decode session is set to run on a CPU implementation and it will decode HEVC</p>
<div class="fragment"><div class="line"><span class="comment">// Default implementation selector. Selects first impl based on option list.</span></div><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1cpu__selector.html">oneapi::vpl::cpu_selector</a> cpu;</div><div class="line"></div><div class="line"><span class="comment">// File reader</span></div><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1bitstream__file__reader.html">oneapi::vpl::bitstream_file_reader</a> fr(source);</div><div class="line"></div><div class="line"><span class="comment">// Load session and initialize decoder</span></div><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1decode__session.html">oneapi::vpl::decode_session</a> decoder(cpu, (mfxU32)oneapi::vpl::codec_format_fourcc::hevc, &amp;fr);</div></div><!-- fragment --><p><a class="anchor" id="invalid"></a></p><h5>Checking to see if a codec is supported</h5>
<p>To check if there is a implementation supports a needed codec, the codec can be passed as a param to a selector which will try to match the codec to an implementation that can support it</p>
<div class="fragment"><div class="line"><span class="comment">// Create property descriptor. Please notice that this is constant expression!</span></div><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1property__name.html">oneapi::vpl::property_name</a> p1;</div><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1property.html">oneapi::vpl::property</a> opt(p1 / <span class="stringliteral">&quot;mfxImplDescription&quot;</span> / <span class="stringliteral">&quot;mfxDecoderDescription&quot;</span> / <span class="stringliteral">&quot;decoder&quot;</span> / <span class="stringliteral">&quot;CodecID&quot;</span>, (uint32_t)vpl::codec_format_fourcc::hevc);</div><div class="line"></div><div class="line"><span class="comment">// Default implementation selector. Selects first impl based on option list.</span></div><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1default__selector.html">oneapi::vpl::default_selector</a> sel({opt});</div><div class="line"></div><div class="line"><span class="comment">// File reader</span></div><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1bitstream__file__reader.html">oneapi::vpl::bitstream_file_reader</a> fr(source);</div><div class="line"></div><div class="line"><span class="comment">// Load session and initialize decoder</span></div><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1decode__session.html">oneapi::vpl::decode_session</a> decoder(sel, MFX_CODEC_HEVC, fr);</div></div><!-- fragment --><p><a class="anchor" id="invalid"></a></p><h5>The simplest initialization for an encode session</h5>
<p>The simplest initialization for an encode session is one that specifies the target device and target codec. In the snippet below, the encode session is set to run on a CPU implementation and it will decode HEVC</p>
<div class="fragment"><div class="line"><span class="comment">// Default implementation selector. Selects first impl based on option list.</span></div><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1cpu__selector.html">oneapi::vpl::cpu_selector</a> cpu;</div><div class="line"></div><div class="line"><span class="comment">// Frame source reader</span></div><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1frame__source__reader.html">oneapi::vpl::frame_source_reader</a> fr(source);</div><div class="line"></div><div class="line"><span class="comment">// Load session and initialize encoder</span></div><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1encode__session.html">oneapi::vpl::encode_session</a> encoder(cpu, fr);</div></div><!-- fragment --><p>The <code>source_reader</code> interface can be subclassed if the default provided readers do not fit your application. Readers deliver data upon request and an end-of-stream flag. Readers should block if data is requested and pending or send an end-of-stream flag.</p>
<p>To decode frames</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;oneapi::vpl::frame_surface&gt; dec_surface_out = std::make_shared&lt;oneapi::vpl::frame_surface&gt;();</div><div class="line"></div><div class="line">decoder.decode_frame(dec_surface_out,{});</div></div><!-- fragment --><p>DecodeFrame is an asynchronous call and will start to decode the frame into the shared ptr.</p>
<p>Once the decoded surface is ready, it may be in non-system memory. The decoded surface will need to be converted to a system buffer</p>
<div class="fragment"><div class="line"><span class="comment">// sync on surface</span></div><div class="line">std::chrono::duration&lt;int, std::milli&gt; waitduration(WAIT_100_MILLSECONDS);</div><div class="line">st = dec_surface_out-&gt;wait_for(waitduration);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (oneapi::vpl::async_op_status::ready == st) {</div><div class="line">    <a class="code" href="classoneapi_1_1vpl_1_1frame__surface.html">oneapi::vpl::frame_surface</a> frame = dec_surface_out-&gt;get();</div><div class="line">    <span class="keyword">auto</span> [info, data] = frame.Map(MFX_MAP_READ);</div><div class="line">    <span class="comment">// Your code that interacts with the frame data</span></div><div class="line">    frame.Unmap();</div><div class="line">}</div></div><!-- fragment --><p>The 2nd argument to DecodeFrame is a list of extension buffers (in the example above, its empty). These extension buffers ask the decoder to do something more or get more information from it.</p>
<p>Each extension buffer is represented by it's corresponding class. Create an object of that class and add to the list.</p>
<p>Example, create an object of DecodeErrorReport extension buffer to get an error report of DecodeFrame</p>
<div class="fragment"><div class="line"><a class="code" href="classoneapi_1_1vpl_1_1ExtDecodeErrorReport.html">oneapi::vpl::ExtDecodeErrorReport</a> err_report;</div><div class="line">std::shared_ptr&lt;oneapi::vpl::frame_surface&gt; dec_surface_out = std::make_shared&lt;oneapi::vpl::frame_surface&gt;();</div><div class="line">wrn = decoder.decode_frame(dec_surface_out,{&amp;err_report});</div><div class="line"></div><div class="line"><span class="comment">// Get error report</span></div><div class="line"><span class="comment">// Before this step, verify decoder processed (due to async behavior),</span></div><div class="line"><span class="comment">// otherwise err_report might not be updated</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;error type = &quot;</span> &lt;&lt; err_report.getRef().ErrorTypes &lt;&lt; std::endl;</div></div><!-- fragment --><p>To encode frames</p>
<div class="fragment"><div class="line">std::shared_ptr&lt;bitstream_as_dst&gt; bs = std::make_shared&lt;oneapi::vpl::bitstream_as_dst&gt;();</div><div class="line"></div><div class="line">encoder.encode_frame(bs,{});</div></div><!-- fragment --><p>EncodeFrame is an asynchronous call and will start to encode the frame into the shared ptr.</p>
<p>Don't worry. For that case we have set of classes inherited from <code>buffer_list</code> class. Thanks to SFINAE we are verifying that you gave us the right extension buffer in the right place.</p>
<ol type="1">
<li>If something really goes wrong (negative mfxStatus) - we will throw the exception. We have our lovely class to catch it.</li>
<li>Warnings (positive mfxStatus) are delivered as the method's return status for now. We know that this is bad but we raised it on oneapi level. </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div class="footer">
  <script>
      $('#top').prependTo($('#side-nav'));
  </script>
  <div class="footer-wrapper">
      <hr>
      <ul class="footer-links">
          <li><p>© Copyright 2021, Intel</p></li>
      </ul>
  </div>
</div>
